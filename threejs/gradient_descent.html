<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gradient Descent</title>
    <link rel="stylesheet" href="shared/prompt.css">
</head>
<body>
    <div class="prompt-container">
        <p>Create an HTML file that uses three.js to visualize gradient descent. This HTML can be generated by a large language model.</p>
        <textarea id="prompt-textbox" readonly>Create an HTML file that uses three.js to visualize gradient descent. This HTML can be generated by a large language model.

1.  Set up the basic HTML structure with a canvas element.
2.  Import the necessary three.js modules.
3.  Create a scene, camera, and renderer.
4.  Create a 3D surface plot of a function.
5.  Create a ball that rolls down the surface to find the minimum.
6.  Implement the gradient descent algorithm in the animation loop.
7.  Add ambient and point lights to the scene.
8.  Add `OrbitControls` to allow the user to move the camera.
9.  Add an event listener to handle window resizing.</textarea>
        <button id="copy-button">Copy Prompt</button>
    </div>




    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 10, 10);

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);

        const func = (x, z) => Math.sin(x) * Math.cos(z) + 1;

        const geometry = new THREE.PlaneGeometry(10, 10, 50, 50);
        const vertices = geometry.attributes.position.array;
        for (let i = 0, j = 0, l = vertices.length; i < l; i++, j += 3) {
            vertices[j + 1] = func(vertices[j], vertices[j + 2]);
        }
        geometry.computeVertexNormals();

        const material = new THREE.MeshStandardMaterial({ color: 0x00ff00, wireframe: true });
        const surface = new THREE.Mesh(geometry, material);
        surface.rotation.x = -Math.PI / 2;
        scene.add(surface);

        const ballGeometry = new THREE.SphereGeometry(0.2, 32, 32);
        const ballMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        const ball = new THREE.Mesh(ballGeometry, ballMaterial);
        ball.position.set(2, func(2, 2) + 0.2, 2);
        scene.add(ball);

        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffffff, 100);
        pointLight.position.set(2, 3, 4);
        scene.add(pointLight);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        const learningRate = 0.01;
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            const x = ball.position.x;
            const z = ball.position.z;

            const dx = Math.cos(x) * Math.cos(z);
            const dz = -Math.sin(x) * Math.sin(z);

            ball.position.x -= learningRate * dx;
            ball.position.z -= learningRate * dz;
            ball.position.y = func(ball.position.x, ball.position.z) + 0.2;

            renderer.render(scene, camera);
        }

        animate();


    </script>
    <script src="shared/prompt.js"></script>
</body>
</html>
