<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CNN Filter</title>
    <link rel="stylesheet" href="shared/prompt.css">
</head>
<body>
    <div class="prompt-container">
        <p>Create an HTML file that uses three.js to visualize a CNN filter. This HTML can be generated by a large language model.</p>
        <textarea id="prompt-textbox" readonly>Create an HTML file that uses three.js to visualize a CNN filter. This HTML can be generated by a large language model.

1.  Set up the basic HTML structure with a canvas element.
2.  Import the necessary three.js modules.
3.  Create a scene, camera, and renderer.
4.  Create a plane with an image texture.
5.  Create a smaller plane to represent the filter.
6.  Create another plane to represent the feature map.
7.  Implement an animation loop that slides the filter over the image and updates the feature map.
8.  Add ambient and point lights to the scene.
9.  Add `OrbitControls` to allow the user to move the camera.
10. Add an event listener to handle window resizing.</textarea>
        <button id="copy-button">Copy Prompt</button>
    </div>




    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);

        const loader = new THREE.TextureLoader();
        const texture = loader.load('https://threejs.org/examples/textures/crate.gif');

        const imageGeometry = new THREE.PlaneGeometry(3, 3);
        const imageMaterial = new THREE.MeshBasicMaterial({ map: texture });
        const image = new THREE.Mesh(imageGeometry, imageMaterial);
        scene.add(image);

        const filterGeometry = new THREE.PlaneGeometry(1, 1);
        const filterMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.5 });
        const filter = new THREE.Mesh(filterGeometry, filterMaterial);
        filter.position.z = 0.1;
        scene.add(filter);

        const featureMapGeometry = new THREE.PlaneGeometry(3, 3);
        const featureMapCanvas = document.createElement('canvas');
        featureMapCanvas.width = 256;
        featureMapCanvas.height = 256;
        const featureMapContext = featureMapCanvas.getContext('2d');
        const featureMapTexture = new THREE.CanvasTexture(featureMapCanvas);
        const featureMapMaterial = new THREE.MeshBasicMaterial({ map: featureMapTexture });
        const featureMap = new THREE.Mesh(featureMapGeometry, featureMapMaterial);
        featureMap.position.x = 4;
        scene.add(featureMap);

        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffffff, 100);
        pointLight.position.set(2, 3, 4);
        scene.add(pointLight);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        let x = -1;
        let y = 1;
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            filter.position.x = x;
            filter.position.y = y;

            x += 0.05;
            if (x > 1) {
                x = -1;
                y -= 0.05;
                if (y < -1) {
                    y = 1;
                }
            }

            featureMapContext.fillStyle = 'black';
            featureMapContext.fillRect(0, 0, 256, 256);
            featureMapContext.fillStyle = 'white';
            featureMapContext.fillRect((x + 1) * 64, (1 - y) * 64, 64, 64);
            featureMapTexture.needsUpdate = true;

            renderer.render(scene, camera);
        }

        animate();


    </script>
    <script src="shared/prompt.js"></script>
</body>
</html>
