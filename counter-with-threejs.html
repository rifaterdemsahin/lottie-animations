<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-R">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Data Visualization with Three.js</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
            background-color: #f0f2f5;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="c"></canvas>

    <script async src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

        let scene, camera, renderer, controls;
        let counterMesh, counterLabelMesh, pieLabelMesh, redPieMesh, hookMesh;
        let font;

        // --- Animation Properties ---
        // We animate these plain objects with GSAP, and then use their
        // values to update the 3D scene in the 'onUpdate' callback.
        const counter = { value: 0 };
        const pieProps = { theta: Math.PI * 2 }; // Start at 100% (2*PI radians)

        const pieRadius = 4;
        const pieHeight = 0.5;

        // --- Materials ---
        const darkTextMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
        const lightTextMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
        const hookTextMat = new THREE.MeshStandardMaterial({ color: 0x000000, transparent: true, opacity: 0 });
        const greenMat = new THREE.MeshStandardMaterial({ color: 0xd4edda });
        const redMat = new THREE.MeshStandardMaterial({ color: 0xf8d7da });

        function init() {
            // --- Basic Scene Setup ---
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f2f5);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 25); // Positioned to see the elements

            renderer = new THREE.WebGLRenderer({ canvas: document.querySelector('#c'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            // --- Lights ---
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            // --- Controls (Optional) ---
            // controls = new OrbitControls(camera, renderer.domElement);
            // controls.enableDamping = true;

            // --- Load Font and Create Scene ---
            const fontLoader = new FontLoader();
            fontLoader.load('https://unpkg.com/three@0.158.0/examples/fonts/helvetiker_regular.typeface.json', (loadedFont) => {
                font = loadedFont;
                createSceneContent();
                startAnimationSequence();
            });

            // --- Handle Window Resize ---
            window.addEventListener('resize', onWindowResize);
            
            // --- Start Render Loop ---
            animate();
        }

        function createSceneContent() {
            const textOptions = {
                font: font,
                size: 1,
                height: 0.1,
                curveSegments: 12,
            };

            // --- 1. Counter ---
            let counterGeo = new TextGeometry('0', { ...textOptions, size: 4 });
            counterGeo.center(); // Center the text geometry
            counterMesh = new THREE.Mesh(counterGeo, darkTextMat.clone());
            counterMesh.position.y = 8;
            scene.add(counterMesh);

            let counterLabelGeo = new TextGeometry('Applications Sent', { ...textOptions, size: 1 });
            counterLabelGeo.center();
            counterLabelMesh = new THREE.Mesh(counterLabelGeo, lightTextMat.clone());
            counterLabelMesh.material.transparent = true;
            counterLabelMesh.material.opacity = 0; // Start hidden
            counterLabelMesh.position.y = 6;
            scene.add(counterLabelMesh);

            // --- 2. Pie Chart ---
            let pieLabelGeo = new TextGeometry('Time Spent: 40hrs \u2794 2hrs', { ...textOptions, size: 0.8 });
            pieLabelGeo.center();
            pieLabelMesh = new THREE.Mesh(pieLabelGeo, darkTextMat.clone());
            pieLabelMesh.material.transparent = true;
            pieLabelMesh.material.opacity = 0; // Start hidden
            pieLabelMesh.position.y = 2.5;
            scene.add(pieLabelMesh);

            // Green Base (100% "Saved Time" visual)
            const greenGeo = new THREE.CylinderGeometry(pieRadius, pieRadius, pieHeight, 64);
            const greenBase = new THREE.Mesh(greenGeo, greenMat);
            greenBase.rotation.x = -Math.PI / 2; // Lay flat
            scene.add(greenBase);

            // Red Slice (Starts at 100%, animates down to 5%)
            // We create the first one; GSAP will update it
            const redGeo = new THREE.CylinderGeometry(pieRadius, pieRadius, pieHeight, 64, 1, false, 0, pieProps.theta);
            redPieMesh = new THREE.Mesh(redGeo, redMat);
            redPieMesh.position.y = 0.01; // Slightly above green
            redPieMesh.rotation.x = -Math.PI / 2; // Lay flat
            redPieMesh.visible = false; // Start hidden
            scene.add(redPieMesh);
            
            // --- 3. Hook Text ---
            let hookGeo = new TextGeometry('I automated 100 job applications in 2 hours using ChatGPT', { ...textOptions, size: 1.1 });
            hookGeo.center();
            hookMesh = new THREE.Mesh(hookGeo, hookTextMat.clone());
            hookMesh.position.y = -5;
            scene.add(hookMesh);
        }

        function startAnimationSequence() {
            // Slower, clearer animation sequence using GSAP Timeline
            const tl = gsap.timeline();

            // --- Phase 1: The Counter (Slower: 3s) ---
            tl.to(counter.value, {
                value: 100,
                duration: 3.0, // Slower (was 2.0s)
                ease: 'power2.out',
                onUpdate: () => {
                    // This is the "3D way" to update text
                    counterMesh.geometry.dispose();
                    counterMesh.geometry = new TextGeometry(
                        Math.floor(counter.value).toString(), 
                        { font: font, size: 4, height: 0.1 }
                    );
                    counterMesh.geometry.center();
                }
            });
            
            // Fade in counter label at the same time
            tl.to(counterLabelMesh.material, { opacity: 1, duration: 1.0 }, "<"); // "<" starts at same time as previous tween

            // --- Phase 2: The Pie Chart (Slower: 2.5s) ---
            // Fade in pie label
            tl.to(pieLabelMesh.material, { opacity: 1, duration: 1.0 }, "-=0.5"); // Overlap slightly
            
            // Make pie visible right before tween starts
            tl.set(redPieMesh, { visible: true });
            
            // Animate the pie
            tl.to(pieProps, {
                theta: Math.PI * 2 * 0.05, // Animate to 5%
                duration: 2.5, // Slower (was 1.5s)
                ease: 'expo.out',
                onUpdate: () => {
                    // Re-create the cylinder geometry based on the new angle
                    redPieMesh.geometry.dispose();
                    redPieMesh.geometry = new THREE.CylinderGeometry(
                        pieRadius, pieRadius, pieHeight, 64, 1, false, 0, pieProps.theta
                    );
                    // We must re-apply the rotation
                    redPieMesh.rotation.x = -Math.PI / 2;
                }
            });

            // --- Phase 3: The Hook Text (Fades in after pie) ---
            tl.to(hookMesh.material, {
                opacity: 1,
                duration: 2.0 // Slower fade-in
            }, "-=0.5"); // Overlap with end of pie animation
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            // if (controls) controls.update(); // Uncomment if using OrbitControls
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
