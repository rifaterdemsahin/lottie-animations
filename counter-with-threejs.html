<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Data Visualization with Three.js</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
            background-color: #f0f2f5;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="c"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script>
        let scene, camera, renderer;
        let counterMesh, counterLabelMesh, pieLabelMesh, redPieMesh, hookMesh;
        let font;

        const counter = { value: 0 };
        const pieProps = { theta: Math.PI * 2 };

        const pieRadius = 4;
        const pieHeight = 0.5;

        const darkTextMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
        const lightTextMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
        const hookTextMat = new THREE.MeshStandardMaterial({ color: 0x000000, transparent: true, opacity: 0 });
        const greenMat = new THREE.MeshStandardMaterial({ color: 0xd4edda });
        const redMat = new THREE.MeshStandardMaterial({ color: 0xf8d7da });

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f2f5);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 25);

            renderer = new THREE.WebGLRenderer({ canvas: document.querySelector('#c'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            const fontLoader = new THREE.FontLoader();
            fontLoader.load('https://unpkg.com/three@0.158.0/examples/fonts/helvetiker_regular.typeface.json', (loadedFont) => {
                font = loadedFont;
                createSceneContent();
                startAnimationSequence();
            });

            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function createSceneContent() {
            const textOptions = {
                font: font,
                size: 1,
                height: 0.1,
                curveSegments: 12,
            };

            let counterGeo = new THREE.TextGeometry('0', { ...textOptions, size: 4 });
            counterGeo.center();
            counterMesh = new THREE.Mesh(counterGeo, darkTextMat.clone());
            counterMesh.position.y = 8;
            scene.add(counterMesh);

            let counterLabelGeo = new THREE.TextGeometry('Applications Sent', { ...textOptions, size: 1 });
            counterLabelGeo.center();
            counterLabelMesh = new THREE.Mesh(counterLabelGeo, lightTextMat.clone());
            counterLabelMesh.material.transparent = true;
            counterLabelMesh.material.opacity = 0;
            counterLabelMesh.position.y = 6;
            scene.add(counterLabelMesh);

            let pieLabelGeo = new THREE.TextGeometry('Time Spent: 40hrs â†’ 2hrs', { ...textOptions, size: 0.8 });
            pieLabelGeo.center();
            pieLabelMesh = new THREE.Mesh(pieLabelGeo, darkTextMat.clone());
            pieLabelMesh.material.transparent = true;
            pieLabelMesh.material.opacity = 0;
            pieLabelMesh.position.y = 2.5;
            scene.add(pieLabelMesh);

            const greenGeo = new THREE.CylinderGeometry(pieRadius, pieRadius, pieHeight, 64);
            const greenBase = new THREE.Mesh(greenGeo, greenMat);
            greenBase.rotation.x = -Math.PI / 2;
            scene.add(greenBase);

            const redGeo = new THREE.CylinderGeometry(pieRadius, pieRadius, pieHeight, 64, 1, false, 0, pieProps.theta);
            redPieMesh = new THREE.Mesh(redGeo, redMat);
            redPieMesh.position.y = 0.01;
            redPieMesh.rotation.x = -Math.PI / 2;
            redPieMesh.visible = false;
            scene.add(redPieMesh);
            
            let hookGeo = new THREE.TextGeometry('I automated 100 job applications in 2 hours using ChatGPT', { ...textOptions, size: 1.1 });
            hookGeo.center();
            hookMesh = new THREE.Mesh(hookGeo, hookTextMat.clone());
            hookMesh.position.y = -5;
            scene.add(hookMesh);
        }

        function startAnimationSequence() {
            const tl = gsap.timeline();

            tl.to(counter, {
                value: 100,
                duration: 3.0,
                ease: 'power2.out',
                onUpdate: () => {
                    counterMesh.geometry.dispose();
                    counterMesh.geometry = new THREE.TextGeometry(
                        Math.floor(counter.value).toString(), 
                        { font: font, size: 4, height: 0.1 }
                    );
                    counterMesh.geometry.center();
                }
            });
            
            tl.to(counterLabelMesh.material, { opacity: 1, duration: 1.0 }, "<");

            tl.to(pieLabelMesh.material, { opacity: 1, duration: 1.0 }, "-=0.5");
            tl.set(redPieMesh, { visible: true });
            
            tl.to(pieProps, {
                theta: Math.PI * 2 * 0.05,
                duration: 2.5,
                ease: 'expo.out',
                onUpdate: () => {
                    redPieMesh.geometry.dispose();
                    redPieMesh.geometry = new THREE.CylinderGeometry(
                        pieRadius, pieRadius, pieHeight, 64, 1, false, 0, pieProps.theta
                    );
                    redPieMesh.rotation.x = -Math.PI / 2;
                }
            });

            tl.to(hookMesh.material, {
                opacity: 1,
                duration: 2.0
            }, "-=0.5");
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
