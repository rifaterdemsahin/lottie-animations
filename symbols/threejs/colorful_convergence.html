<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Colorful Convergence</title>
    <link rel="stylesheet" href="shared/prompt.css">
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <div class="prompt-container">
        <p>Create an HTML file that uses three.js to visualize colorful icons converging to the center. This HTML can be generated by a large language model.</p>
        <textarea id="prompt-textbox" readonly>Create an HTML file that uses three.js to visualize colorful icons converging to the center. This HTML can be generated by a large language model.

1. Set up the basic HTML structure with a canvas element.
2. Import the necessary three.js modules.
3. Create a scene, camera, and renderer.
4. Create multiple colorful geometric shapes (icons) positioned around the scene.
5. Each icon should have a distinct vibrant color (red, blue, green, yellow, purple, orange, cyan, pink).
6. Implement an animation that slowly moves all icons toward the center over 5 seconds.
7. As icons converge, their colors should merge into a single unified color.
8. Add ambient and point lights to the scene.
9. Add OrbitControls to allow the user to move the camera.
10. Add an event listener to handle window resizing.</textarea>
        <button id="copy-button">Copy Prompt</button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 15);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Colorful icons array - each with position, color, and mesh
        const colors = [
            0xff0000, // Red
            0x0000ff, // Blue
            0x00ff00, // Green
            0xffff00, // Yellow
            0xff00ff, // Magenta
            0xff8800, // Orange
            0x00ffff, // Cyan
            0xff0088, // Pink
            0x8800ff, // Purple
            0x00ff88, // Teal
            0xffaa00, // Amber
            0x88ff00  // Lime
        ];

        const icons = [];
        const iconCount = colors.length;
        const radius = 8; // Starting radius for icons

        // Create colorful icons positioned in a circle
        colors.forEach((color, index) => {
            const angle = (index / iconCount) * Math.PI * 2;
            const x = Math.cos(angle) * radius;
            const y = Math.sin(angle) * radius;
            const z = (Math.random() - 0.5) * 4;

            // Create different geometric shapes for variety
            let geometry;
            if (index % 4 === 0) {
                geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            } else if (index % 4 === 1) {
                geometry = new THREE.SphereGeometry(0.5, 16, 16);
            } else if (index % 4 === 2) {
                geometry = new THREE.ConeGeometry(0.5, 1, 8);
            } else {
                geometry = new THREE.OctahedronGeometry(0.6);
            }

            const material = new THREE.MeshStandardMaterial({ 
                color: color,
                emissive: color,
                emissiveIntensity: 0.3,
                metalness: 0.7,
                roughness: 0.3
            });

            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            
            // Store initial position and color
            icons.push({
                mesh: mesh,
                initialPosition: new THREE.Vector3(x, y, z),
                color: color,
                targetPosition: new THREE.Vector3(0, 0, 0)
            });

            scene.add(mesh);
        });

        // Add ambient and point lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const pointLight1 = new THREE.PointLight(0xffffff, 1.5, 100);
        pointLight1.position.set(5, 5, 5);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0xffffff, 1.5, 100);
        pointLight2.position.set(-5, -5, -5);
        scene.add(pointLight2);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(0, 10, 0);
        scene.add(directionalLight);

        // Animation variables
        const animationDuration = 5.0; // 5 seconds
        let animationTime = 0;
        let isAnimating = true;

        // Calculate merged color (average of all colors)
        function calculateMergedColor() {
            let r = 0, g = 0, b = 0;
            colors.forEach(color => {
                r += (color >> 16) & 0xff;
                g += (color >> 8) & 0xff;
                b += color & 0xff;
            });
            r = Math.floor(r / colors.length);
            g = Math.floor(g / colors.length);
            b = Math.floor(b / colors.length);
            return (r << 16) | (g << 8) | b;
        }

        const mergedColor = calculateMergedColor();

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            if (isAnimating && animationTime < animationDuration) {
                animationTime += 0.016; // ~60fps
                const progress = Math.min(animationTime / animationDuration, 1);
                
                // Use easing function for smooth animation
                const easedProgress = progress < 0.5 
                    ? 2 * progress * progress 
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                icons.forEach(icon => {
                    // Interpolate position
                    icon.mesh.position.lerpVectors(
                        icon.initialPosition,
                        icon.targetPosition,
                        easedProgress
                    );

                    // Interpolate color - lerp from current color to target color
                    const startColor = new THREE.Color(icon.color);
                    const endColor = new THREE.Color(mergedColor);
                    icon.mesh.material.color.lerpColors(startColor, endColor, easedProgress);
                    icon.mesh.material.emissive.lerpColors(startColor, endColor, easedProgress * 0.3);

                    // Slowly rotate icons
                    icon.mesh.rotation.x += 0.01;
                    icon.mesh.rotation.y += 0.01;
                });

                // Stop animation after completion
                if (progress >= 1) {
                    isAnimating = false;
                }
            } else {
                // Continue rotating after convergence
                icons.forEach(icon => {
                    icon.mesh.rotation.x += 0.01;
                    icon.mesh.rotation.y += 0.01;
                });
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
    <script src="shared/prompt.js"></script>
</body>
</html>

