<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cognitive Style Navigator</title>
    <link rel="stylesheet" href="shared/prompt.css">
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <div class="prompt-container">
        <p>Build a Three.js scene that contrasts four cognitive styles with distinct motion language: a solution-oriented sine flow, a problem-oriented circular loop, an emotional star pulse, and a rational arrow traveling from A to B.</p>
        <textarea id="prompt-textbox" readonly>Build a Three.js scene that contrasts four cognitive styles with distinct motion language:

1. Set up HTML with Three.js import map, OrbitControls, and prompt tooling.
2. Create a dark scene, responsive renderer, and interactive controls.
3. Add ambient and point lighting for depth and highlights.
4. Implement a solution-oriented sine wave that ripples continuously.
5. Implement a problem-oriented circular path with an orbiting marker.
6. Implement an emotional star that pulses and rolls.
7. Implement a rational arrow that tracks motion from point A to point B.
8. Label each style with bold 3D text anchored to its geometry.
9. Keep animation loops performant with requestAnimationFrame.
10. Handle window resizing to maintain aspect ratio.
11. Load helvetiker font from the Three.js CDN for typography.</textarea>
        <button id="copy-button">Copy Prompt</button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x05050b);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 120);
        camera.position.set(0, 0, 28);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.08;

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.55);
        scene.add(ambientLight);

        const pointLightA = new THREE.PointLight(0xffffff, 1.6, 140);
        pointLightA.position.set(16, 10, 18);
        scene.add(pointLightA);

        const pointLightB = new THREE.PointLight(0xffffff, 1.2, 140);
        pointLightB.position.set(-14, -12, -16);
        scene.add(pointLightB);

        const styles = [];
        const clock = new THREE.Clock();

        const fontLoader = new FontLoader();
        fontLoader.load('https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_regular.typeface.json', font => {
            createStyles(font);
        });

        function createLabel(text, font, color, size = 0.9) {
            const geometry = new TextGeometry(text, {
                font,
                size,
                height: 0.24,
                curveSegments: 18,
                bevelEnabled: true,
                bevelThickness: 0.05,
                bevelSize: 0.04,
                bevelSegments: 4
            });
            geometry.center();
            const material = new THREE.MeshStandardMaterial({
                color,
                emissive: color,
                emissiveIntensity: 0.4,
                metalness: 0.45,
                roughness: 0.35
            });
            return new THREE.Mesh(geometry, material);
        }

        function createStyles(font) {
            const solutionGroup = new THREE.Group();
            const solutionPoints = 240;
            const solutionPositions = new Float32Array(solutionPoints * 3);
            const solutionBase = new Float32Array(solutionPoints);
            for (let i = 0; i < solutionPoints; i++) {
                const t = i / (solutionPoints - 1);
                const x = t * 12 - 6;
                solutionBase[i] = x;
                solutionPositions[i * 3] = x;
                solutionPositions[i * 3 + 1] = 0;
                solutionPositions[i * 3 + 2] = 0;
            }
            const solutionGeometry = new THREE.BufferGeometry();
            solutionGeometry.setAttribute('position', new THREE.BufferAttribute(solutionPositions, 3));
            const solutionMaterial = new THREE.LineBasicMaterial({ color: 0x5bc0f8, linewidth: 2 });
            const solutionLine = new THREE.Line(solutionGeometry, solutionMaterial);
            solutionLine.scale.set(0.9, 1.5, 1);
            solutionGroup.add(solutionLine);
            const solutionLabel = createLabel('Solution-Oriented', font, 0x5bc0f8);
            solutionLabel.position.set(0, 3.1, 0);
            solutionGroup.add(solutionLabel);
            solutionGroup.position.set(-9, 5, 0);
            scene.add(solutionGroup);
            styles.push({
                update(elapsed) {
                    const amplitude = 1.8;
                    const speed = 1.4;
                    const offset = elapsed * speed;
                    const array = solutionGeometry.attributes.position.array;
                    for (let i = 0; i < solutionPoints; i++) {
                        array[i * 3 + 1] = Math.sin(solutionBase[i] + offset) * amplitude;
                    }
                    solutionGeometry.attributes.position.needsUpdate = true;
                    solutionLine.rotation.z = Math.sin(elapsed * 0.6) * 0.12;
                }
            });

            const problemGroup = new THREE.Group();
            const ringGeometry = new THREE.RingGeometry(2.4, 3.2, 96, 1);
            const ringMaterial = new THREE.MeshStandardMaterial({
                color: 0xff9f1c,
                emissive: 0xff9f1c,
                emissiveIntensity: 0.55,
                side: THREE.DoubleSide,
                metalness: 0.5,
                roughness: 0.3
            });
            const problemRing = new THREE.Mesh(ringGeometry, ringMaterial);
            problemRing.rotation.x = Math.PI / 2;
            problemGroup.add(problemRing);
            const orbitMarker = new THREE.Mesh(new THREE.SphereGeometry(0.45, 28, 28), new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffd166, emissiveIntensity: 0.9 }));
            orbitMarker.position.set(3.2, 0, 0);
            problemGroup.add(orbitMarker);
            const problemLabel = createLabel('Problem-Oriented', font, 0xff9f1c);
            problemLabel.position.set(0, 3.2, 0);
            problemGroup.add(problemLabel);
            problemGroup.position.set(9, 5, 0);
            scene.add(problemGroup);
            styles.push({
                update(elapsed) {
                    const orbitRadius = 3.2;
                    const angle = elapsed * 1.6;
                    orbitMarker.position.set(Math.cos(angle) * orbitRadius, Math.sin(angle) * orbitRadius, 0);
                    problemGroup.rotation.z = Math.sin(elapsed * 0.8) * 0.2;
                    problemRing.rotation.y += 0.01;
                }
            });

            const emotionalGroup = new THREE.Group();
            const starShape = new THREE.Shape();
            const starPoints = 10;
            const outer = 3.3;
            const inner = 1.4;
            for (let i = 0; i < starPoints * 2; i++) {
                const angle = (i / (starPoints * 2)) * Math.PI * 2;
                const radius = i % 2 === 0 ? outer : inner;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if (i === 0) {
                    starShape.moveTo(x, y);
                } else {
                    starShape.lineTo(x, y);
                }
            }
            starShape.closePath();
            const starGeometry = new THREE.ExtrudeGeometry(starShape, {
                depth: 0.8,
                bevelEnabled: true,
                bevelThickness: 0.25,
                bevelSize: 0.18,
                bevelSegments: 4
            });
            const starMaterial = new THREE.MeshStandardMaterial({ color: 0xff477e, emissive: 0xff477e, emissiveIntensity: 0.65, metalness: 0.2, roughness: 0.45 });
            const starMesh = new THREE.Mesh(starGeometry, starMaterial);
            starMesh.rotation.x = Math.PI / 6;
            emotionalGroup.add(starMesh);
            const emotionalLabel = createLabel('Emotional', font, 0xff477e);
            emotionalLabel.position.set(0, 3.6, 0);
            emotionalGroup.add(emotionalLabel);
            emotionalGroup.position.set(-9, -5, 0);
            scene.add(emotionalGroup);
            styles.push({
                update(elapsed) {
                    const pulse = 1 + Math.sin(elapsed * 3) * 0.18;
                    starMesh.scale.set(pulse, pulse, pulse);
                    starMesh.rotation.z += 0.015;
                    emotionalGroup.rotation.y = Math.sin(elapsed * 0.7) * 0.25;
                }
            });

            const rationalGroup = new THREE.Group();
            const startPoint = new THREE.Vector3(-4.5, -1.6, 0);
            const endPoint = new THREE.Vector3(4.5, 1.6, 0);
            const direction = endPoint.clone().sub(startPoint).normalize();
            const arrowLength = startPoint.distanceTo(endPoint);
            const arrowHelper = new THREE.ArrowHelper(direction, startPoint, arrowLength, 0x8ecae6, 1.2, 0.7);
            rationalGroup.add(arrowHelper);
            const tracer = new THREE.Mesh(new THREE.SphereGeometry(0.5, 32, 32), new THREE.MeshStandardMaterial({ color: 0x219ebc, emissive: 0x219ebc, emissiveIntensity: 0.7 }));
            rationalGroup.add(tracer);
            const labelA = createLabel('A', font, 0xffffff, 0.65);
            labelA.position.copy(startPoint.clone().add(new THREE.Vector3(-0.3, -1.1, 0)));
            rationalGroup.add(labelA);
            const labelB = createLabel('B', font, 0xffffff, 0.65);
            labelB.position.copy(endPoint.clone().add(new THREE.Vector3(0.3, 1.1, 0)));
            rationalGroup.add(labelB);
            const rationalLabel = createLabel('Rational', font, 0x8ecae6);
            rationalLabel.position.set(0, 3, 0);
            rationalGroup.add(rationalLabel);
            rationalGroup.position.set(9, -5, 0);
            scene.add(rationalGroup);
            styles.push({
                update(elapsed) {
                    const travel = (Math.sin(elapsed * 1.2) + 1) * 0.5;
                    const position = startPoint.clone().lerp(endPoint, travel);
                    tracer.position.copy(position);
                    rationalGroup.rotation.x = Math.sin(elapsed * 0.4) * 0.1;
                    rationalGroup.rotation.z = Math.cos(elapsed * 0.4) * 0.12;
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            const elapsed = clock.getElapsedTime();
            styles.forEach(style => style.update?.(elapsed));
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
    <script src="shared/prompt.js"></script>
</body>
</html>
