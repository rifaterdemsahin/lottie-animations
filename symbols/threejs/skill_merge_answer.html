<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skill Merge - AI Answer Generation</title>
    <link rel="stylesheet" href="shared/prompt.css">
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <div class="prompt-container">
        <p>Create an HTML file that uses three.js to visualize ChatGPT, CV, and Job Description merging to create a unique answer. This HTML can be generated by a large language model.</p>
        <textarea id="prompt-textbox" readonly>Create an HTML file that uses three.js to visualize ChatGPT, CV, and Job Description merging to create a unique answer. This HTML can be generated by a large language model.

1. Set up the basic HTML structure with a canvas element.
2. Import the necessary three.js modules.
3. Create a scene, camera, and renderer.
4. Create three distinct 3D components representing ChatGPT, CV, and Job Description.
5. Each component should display skill names relevant to its purpose.
6. Implement an animation that slowly moves all components toward the center over 6 seconds.
7. As components converge, their colors and content should merge.
8. After merging, display a unique answer/result at the center.
9. Add ambient and point lights to the scene.
10. Add OrbitControls to allow the user to move the camera.
11. Add an event listener to handle window resizing.</textarea>
        <button id="copy-button">Copy Prompt</button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 20);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Component definitions with skills
        const components = [
            {
                name: 'ChatGPT',
                color: 0x00aaff,
                position: new THREE.Vector3(-8, 0, 0),
                skills: ['AI', 'NLP', 'Analysis', 'Generation', 'Context'],
                icon: 'ðŸ¤–'
            },
            {
                name: 'CV',
                color: 0xff6b6b,
                position: new THREE.Vector3(0, 8, 0),
                skills: ['Experience', 'Skills', 'Education', 'Projects', 'Achievements'],
                icon: 'ðŸ“„'
            },
            {
                name: 'Job Description',
                color: 0x4ecdc4,
                position: new THREE.Vector3(8, 0, 0),
                skills: ['Requirements', 'Role', 'Company', 'Culture', 'Expectations'],
                icon: 'ðŸ’¼'
            }
        ];

        const meshes = [];
        let font = null;
        let answerText = [];

        // Load font
        const fontLoader = new FontLoader();
        fontLoader.load('https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_regular.typeface.json', (loadedFont) => {
            font = loadedFont;
            createScene();
            animate();
        });

        function createScene() {
            // Create components with skill text
            components.forEach((component, index) => {
                // Create main box for component
                const geometry = new THREE.BoxGeometry(3, 4, 0.5);
                const material = new THREE.MeshStandardMaterial({
                    color: component.color,
                    emissive: component.color,
                    emissiveIntensity: 0.3,
                    metalness: 0.7,
                    roughness: 0.3
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(component.position);
                mesh.userData = {
                    component: component,
                    initialPosition: component.position.clone(),
                    targetPosition: new THREE.Vector3(0, 0, 0)
                };
                scene.add(mesh);
                meshes.push(mesh);

                // Create component name text - keep in place, don't move with object
                const nameGeo = new TextGeometry(component.name, {
                    font: font,
                    size: 0.7,
                    height: 0.15,
                    curveSegments: 12
                });
                nameGeo.center();
                const nameMat = new THREE.MeshStandardMaterial({ 
                    color: 0xffffff,
                    emissive: 0xffffff,
                    emissiveIntensity: 0.3
                });
                const nameMesh = new THREE.Mesh(nameGeo, nameMat);
                nameMesh.position.set(component.position.x, component.position.y + 2, component.position.z + 0.3);
                nameMesh.userData = { component: component, isText: true, initialPosition: component.position.clone() };
                scene.add(nameMesh); // Add to scene directly, not as child

                // Create skill text for each component - keep in place
                component.skills.forEach((skill, skillIndex) => {
                    const skillGeo = new TextGeometry(skill, {
                        font: font,
                        size: 0.4,
                        height: 0.08,
                        curveSegments: 10
                    });
                    skillGeo.center();
                    const skillMat = new THREE.MeshStandardMaterial({ 
                        color: component.color,
                        emissive: component.color,
                        emissiveIntensity: 0.6
                    });
                    const skillMesh = new THREE.Mesh(skillGeo, skillMat);
                    const offsetY = -0.5 - (skillIndex * 0.5);
                    skillMesh.position.set(component.position.x, component.position.y + offsetY, component.position.z + 0.3);
                    skillMesh.userData = { component: component, isText: true, initialPosition: component.position.clone() };
                    scene.add(skillMesh); // Add to scene directly, not as child
                });
            });

            // Create package-like merged result (initially hidden)
            // Main package box
            const packageGeo = new THREE.BoxGeometry(4, 3, 2);
            const packageMat = new THREE.MeshStandardMaterial({
                color: 0xffd700, // Golden package color
                emissive: 0xffd700,
                emissiveIntensity: 0.4,
                metalness: 0.8,
                roughness: 0.3
            });
            const packageMesh = new THREE.Mesh(packageGeo, packageMat);
            packageMesh.position.set(0, 0, 0);
            packageMesh.scale.set(0, 0, 0);
            packageMesh.visible = false;
            packageMesh.userData.isPackage = true;
            scene.add(packageMesh);
            meshes.push(packageMesh);

            // Package lid (top)
            const lidGeo = new THREE.BoxGeometry(4.2, 0.3, 2.2);
            const lidMat = new THREE.MeshStandardMaterial({
                color: 0xffb347, // Darker gold for lid
                emissive: 0xffb347,
                emissiveIntensity: 0.3,
                metalness: 0.7,
                roughness: 0.4
            });
            const lidMesh = new THREE.Mesh(lidGeo, lidMat);
            lidMesh.position.set(0, 1.65, 0);
            lidMesh.scale.set(0, 0, 0);
            lidMesh.visible = false;
            lidMesh.userData.isPackagePart = true;
            scene.add(lidMesh);
            meshes.push(lidMesh);

            // Package ribbon/tape (crossing strips)
            const ribbonGeo1 = new THREE.BoxGeometry(4.5, 0.15, 0.3);
            const ribbonMat = new THREE.MeshStandardMaterial({
                color: 0xfff8dc, // Light gold/cream ribbon for contrast
                emissive: 0xfff8dc,
                emissiveIntensity: 0.4,
                metalness: 0.9,
                roughness: 0.1
            });
            const ribbon1 = new THREE.Mesh(ribbonGeo1, ribbonMat);
            ribbon1.position.set(0, 0, 0);
            ribbon1.scale.set(0, 0, 0);
            ribbon1.visible = false;
            ribbon1.userData.isPackagePart = true;
            scene.add(ribbon1);
            meshes.push(ribbon1);

            const ribbonGeo2 = new THREE.BoxGeometry(0.3, 3.5, 0.3);
            const ribbon2 = new THREE.Mesh(ribbonGeo2, ribbonMat);
            ribbon2.position.set(0, 0, 0);
            ribbon2.scale.set(0, 0, 0);
            ribbon2.visible = false;
            ribbon2.userData.isPackagePart = true;
            scene.add(ribbon2);
            meshes.push(ribbon2);

            // "DYNAMIC RESPONSE" text at bottom of package
            const responseText = 'DYNAMIC RESPONSE';
            const responseGeo = new TextGeometry(responseText, {
                font: font,
                size: 0.5,
                height: 0.1,
                curveSegments: 12
            });
            responseGeo.center();
            const responseMat = new THREE.MeshStandardMaterial({
                color: 0x000000,
                emissive: 0xffd700,
                emissiveIntensity: 0.8
            });
            const responseMesh = new THREE.Mesh(responseGeo, responseMat);
            responseMesh.position.set(0, -2.2, 1.1); // Bottom of package
            responseMesh.scale.set(0, 0, 0);
            responseMesh.visible = false;
            responseMesh.userData.isAnswer = true;
            scene.add(responseMesh);
            answerText.push(responseMesh);
        }

        // Add lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const pointLight1 = new THREE.PointLight(0xffffff, 1.5, 100);
        pointLight1.position.set(5, 5, 5);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0xffffff, 1.5, 100);
        pointLight2.position.set(-5, -5, -5);
        scene.add(pointLight2);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(0, 10, 0);
        scene.add(directionalLight);

        // Animation variables
        const animationDuration = 6.0; // 6 seconds
        let animationTime = 0;
        let isAnimating = true;
        let showResult = false;

        // Calculate merged color (average of all component colors)
        function calculateMergedColor() {
            let r = 0, g = 0, b = 0;
            components.forEach(component => {
                r += (component.color >> 16) & 0xff;
                g += (component.color >> 8) & 0xff;
                b += component.color & 0xff;
            });
            r = Math.floor(r / components.length);
            g = Math.floor(g / components.length);
            b = Math.floor(b / components.length);
            return (r << 16) | (g << 8) | b;
        }

        const mergedColor = calculateMergedColor();

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            if (isAnimating && animationTime < animationDuration) {
                animationTime += 0.016; // ~60fps
                const progress = Math.min(animationTime / animationDuration, 1);
                
                // Use easing function for smooth animation
                const easedProgress = progress < 0.5 
                    ? 2 * progress * progress 
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                // Move components toward center
                meshes.forEach((mesh, index) => {
                    if (index < components.length && mesh.userData.initialPosition) {
                        // Interpolate position
                        mesh.position.lerpVectors(
                            mesh.userData.initialPosition,
                            mesh.userData.targetPosition,
                            easedProgress
                        );

                        // Interpolate color
                        const startColor = new THREE.Color(mesh.userData.component.color);
                        const endColor = new THREE.Color(mergedColor);
                        mesh.material.color.lerpColors(startColor, endColor, easedProgress);
                        mesh.material.emissive.lerpColors(startColor, endColor, easedProgress * 0.3);

                        // Slowly rotate
                        mesh.rotation.y += 0.01;
                    }
                });

                // Update text colors as objects converge (text stays in place, only colors change)
                scene.children.forEach(child => {
                    if (child.userData && child.userData.isText && !child.userData.isAnswer) {
                        const component = child.userData.component;
                        const startColor = new THREE.Color(component.color);
                        const endColor = new THREE.Color(mergedColor);
                        if (child.material.color) {
                            child.material.color.lerpColors(startColor, endColor, easedProgress);
                        }
                        if (child.material.emissive) {
                            child.material.emissive.lerpColors(startColor, endColor, easedProgress * 0.3);
                        }
                    }
                });

                // Show package result in the last 25% of animation
                if (progress > 0.75 && !showResult) {
                    showResult = true;
                    // Show all package parts
                    meshes.forEach(mesh => {
                        if (mesh.userData.isPackage || mesh.userData.isPackagePart) {
                            mesh.visible = true;
                        }
                    });
                    answerText.forEach(text => text.visible = true);
                }

                if (showResult) {
                    const resultProgress = (progress - 0.75) / 0.25; // Scale to 0-1
                    const scale = THREE.MathUtils.smoothstep(0, 1, resultProgress);
                    
                    // Scale all package parts together
                    meshes.forEach(mesh => {
                        if (mesh.userData.isPackage || mesh.userData.isPackagePart) {
                            mesh.scale.set(scale, scale, scale);
                            // Rotate package slightly
                            mesh.rotation.y += 0.01;
                        }
                    });
                    
                    // Scale and rotate text
                    answerText.forEach(text => {
                        const textScale = THREE.MathUtils.smoothstep(0, 1, resultProgress);
                        text.scale.set(textScale, textScale, textScale);
                        text.rotation.y += 0.02;
                    });
                }

                // Stop animation after completion
                if (progress >= 1) {
                    isAnimating = false;
                }
            } else {
                // Continue rotating after convergence
                meshes.forEach(mesh => {
                    if (mesh.userData.isPackage || mesh.userData.isPackagePart) {
                        mesh.rotation.y += 0.01;
                    } else {
                        mesh.rotation.y += 0.01;
                    }
                });
                answerText.forEach(text => text.rotation.y += 0.02);
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
    <script src="shared/prompt.js"></script>
</body>
</html>

