<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skill Merge - AI Answer Generation</title>
    <link rel="stylesheet" href="shared/prompt.css">
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <div class="prompt-container">
        <p>Create an HTML file that uses three.js to visualize ChatGPT, CV, and Job Description merging to create a unique answer. This HTML can be generated by a large language model.</p>
        <textarea id="prompt-textbox" readonly>Create an HTML file that uses three.js to visualize ChatGPT, CV, and Job Description merging to create a unique answer. This HTML can be generated by a large language model.

1. Set up the basic HTML structure with a canvas element.
2. Import the necessary three.js modules.
3. Create a scene, camera, and renderer.
4. Create three distinct 3D components representing ChatGPT, CV, and Job Description.
5. Each component should display skill names relevant to its purpose.
6. Implement an animation that slowly moves all components toward the center over 6 seconds.
7. As components converge, their colors and content should merge.
8. After merging, display a unique answer/result at the center.
9. Add ambient and point lights to the scene.
10. Add OrbitControls to allow the user to move the camera.
11. Add an event listener to handle window resizing.</textarea>
        <button id="copy-button">Copy Prompt</button>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 20);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Component definitions with skills
        const components = [
            {
                name: 'ChatGPT',
                color: 0x00aaff,
                position: new THREE.Vector3(-8, 0, 0),
                skills: ['AI', 'NLP', 'Analysis', 'Generation', 'Context'],
                icon: 'ðŸ¤–'
            },
            {
                name: 'CV',
                color: 0xff6b6b,
                position: new THREE.Vector3(0, 8, 0),
                skills: ['Experience', 'Skills', 'Education', 'Projects', 'Achievements'],
                icon: 'ðŸ“„'
            },
            {
                name: 'Job Description',
                color: 0x4ecdc4,
                position: new THREE.Vector3(8, 0, 0),
                skills: ['Requirements', 'Role', 'Company', 'Culture', 'Expectations'],
                icon: 'ðŸ’¼'
            }
        ];

        const meshes = [];
        let font = null;
        let answerText = [];

        // Load font
        const fontLoader = new FontLoader();
        fontLoader.load('https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_regular.typeface.json', (loadedFont) => {
            font = loadedFont;
            createScene();
            animate();
        });

        function createScene() {
            // Create components with skill text
            components.forEach((component, index) => {
                // Create main box for component
                const geometry = new THREE.BoxGeometry(3, 4, 0.5);
                const material = new THREE.MeshStandardMaterial({
                    color: component.color,
                    emissive: component.color,
                    emissiveIntensity: 0.3,
                    metalness: 0.7,
                    roughness: 0.3
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(component.position);
                mesh.userData = {
                    component: component,
                    initialPosition: component.position.clone(),
                    targetPosition: new THREE.Vector3(0, 0, 0)
                };
                scene.add(mesh);
                meshes.push(mesh);

                // Create component name text - attach to mesh so it moves with the object
                const nameGeo = new TextGeometry(component.name, {
                    font: font,
                    size: 0.7,
                    height: 0.15,
                    curveSegments: 12
                });
                nameGeo.center();
                const nameMat = new THREE.MeshStandardMaterial({ 
                    color: 0xffffff,
                    emissive: 0xffffff,
                    emissiveIntensity: 0.3
                });
                const nameMesh = new THREE.Mesh(nameGeo, nameMat);
                nameMesh.position.set(0, 2, 0.3); // Relative to parent mesh
                nameMesh.userData = { component: component, isText: true };
                mesh.add(nameMesh); // Add as child so it moves with the mesh

                // Create skill text for each component - attach to mesh
                component.skills.forEach((skill, skillIndex) => {
                    const skillGeo = new TextGeometry(skill, {
                        font: font,
                        size: 0.4,
                        height: 0.08,
                        curveSegments: 10
                    });
                    skillGeo.center();
                    const skillMat = new THREE.MeshStandardMaterial({ 
                        color: component.color,
                        emissive: component.color,
                        emissiveIntensity: 0.6
                    });
                    const skillMesh = new THREE.Mesh(skillGeo, skillMat);
                    const offsetY = -0.5 - (skillIndex * 0.5);
                    skillMesh.position.set(0, offsetY, 0.3); // Relative to parent mesh
                    skillMesh.userData = { component: component, isText: true };
                    mesh.add(skillMesh); // Add as child so it moves with the mesh
                });
            });

            // Create final answer text (initially hidden) - make it bigger and bold
            const answerLines = [
                'Customized',
                'Cover Letter',
                'Generated!'
            ];
            
            answerLines.forEach((line, index) => {
                const answerGeo = new TextGeometry(line, {
                    font: font,
                    size: 0.8,
                    height: 0.2,
                    curveSegments: 12
                });
                answerGeo.center();
                const answerMat = new THREE.MeshStandardMaterial({ 
                    color: 0xffffff,
                    emissive: 0x00ff88,
                    emissiveIntensity: 0.8
                });
                const answerMesh = new THREE.Mesh(answerGeo, answerMat);
                answerMesh.position.set(0, -2 + (index * 1), 0);
                answerMesh.scale.set(0, 0, 0);
                answerMesh.visible = false;
                answerMesh.userData.isAnswer = true;
                scene.add(answerMesh);
                answerText.push(answerMesh);
            });

            // Create merged result box (initially hidden)
            const resultGeo = new THREE.BoxGeometry(5, 3, 0.5);
            const resultMat = new THREE.MeshStandardMaterial({
                color: 0x00ff88,
                emissive: 0x00ff88,
                emissiveIntensity: 0.5,
                metalness: 0.8,
                roughness: 0.2
            });
            const resultMesh = new THREE.Mesh(resultGeo, resultMat);
            resultMesh.position.set(0, 0, 0);
            resultMesh.scale.set(0, 0, 0);
            resultMesh.visible = false;
            scene.add(resultMesh);
            meshes.push(resultMesh);
        }

        // Add lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const pointLight1 = new THREE.PointLight(0xffffff, 1.5, 100);
        pointLight1.position.set(5, 5, 5);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0xffffff, 1.5, 100);
        pointLight2.position.set(-5, -5, -5);
        scene.add(pointLight2);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(0, 10, 0);
        scene.add(directionalLight);

        // Animation variables
        const animationDuration = 6.0; // 6 seconds
        let animationTime = 0;
        let isAnimating = true;
        let showResult = false;

        // Calculate merged color (average of all component colors)
        function calculateMergedColor() {
            let r = 0, g = 0, b = 0;
            components.forEach(component => {
                r += (component.color >> 16) & 0xff;
                g += (component.color >> 8) & 0xff;
                b += component.color & 0xff;
            });
            r = Math.floor(r / components.length);
            g = Math.floor(g / components.length);
            b = Math.floor(b / components.length);
            return (r << 16) | (g << 8) | b;
        }

        const mergedColor = calculateMergedColor();

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            if (isAnimating && animationTime < animationDuration) {
                animationTime += 0.016; // ~60fps
                const progress = Math.min(animationTime / animationDuration, 1);
                
                // Use easing function for smooth animation
                const easedProgress = progress < 0.5 
                    ? 2 * progress * progress 
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                // Move components toward center
                meshes.forEach((mesh, index) => {
                    if (index < components.length && mesh.userData.initialPosition) {
                        // Interpolate position
                        mesh.position.lerpVectors(
                            mesh.userData.initialPosition,
                            mesh.userData.targetPosition,
                            easedProgress
                        );

                        // Interpolate color
                        const startColor = new THREE.Color(mesh.userData.component.color);
                        const endColor = new THREE.Color(mergedColor);
                        mesh.material.color.lerpColors(startColor, endColor, easedProgress);
                        mesh.material.emissive.lerpColors(startColor, endColor, easedProgress * 0.3);

                        // Slowly rotate
                        mesh.rotation.y += 0.01;
                    }
                });

                // Update text colors as objects converge (text moves with objects since they're children)
                meshes.forEach((mesh, index) => {
                    if (index < components.length) {
                        const component = components[index];
                        // Update colors of text children
                        mesh.children.forEach(child => {
                            if (child.userData.isText) {
                                const startColor = new THREE.Color(component.color);
                                const endColor = new THREE.Color(mergedColor);
                                if (child.material.color) {
                                    child.material.color.lerpColors(startColor, endColor, easedProgress);
                                }
                                if (child.material.emissive) {
                                    child.material.emissive.lerpColors(startColor, endColor, easedProgress * 0.3);
                                }
                            }
                        });
                    }
                });

                // Show result in the last 25% of animation
                if (progress > 0.75 && !showResult) {
                    showResult = true;
                    const resultMesh = meshes[meshes.length - 1];
                    resultMesh.visible = true;
                    answerText.forEach(text => text.visible = true);
                }

                if (showResult) {
                    const resultProgress = (progress - 0.75) / 0.25; // Scale to 0-1
                    const resultMesh = meshes[meshes.length - 1];
                    const scale = THREE.MathUtils.smoothstep(0, 1, resultProgress);
                    resultMesh.scale.set(scale, scale, scale);
                    answerText.forEach((text, index) => {
                        const delay = index * 0.2;
                        const textProgress = Math.max(0, Math.min(1, (resultProgress - delay) / (1 - delay)));
                        const textScale = THREE.MathUtils.smoothstep(0, 1, textProgress);
                        text.scale.set(textScale, textScale, textScale);
                        text.rotation.y += 0.02;
                    });
                }

                // Stop animation after completion
                if (progress >= 1) {
                    isAnimating = false;
                }
            } else {
                // Continue rotating after convergence
                meshes.forEach(mesh => {
                    mesh.rotation.y += 0.01;
                });
                answerText.forEach(text => text.rotation.y += 0.02);
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
    <script src="shared/prompt.js"></script>
</body>
</html>

